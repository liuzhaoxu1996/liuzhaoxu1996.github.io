(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{423:function(v,t,e){"use strict";e.r(t);var _=e(25),r=Object(_.a)({},(function(){var v=this,t=v.$createElement,e=v._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"vue题目汇总"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue题目汇总"}},[v._v("#")]),v._v(" Vue题目汇总")]),v._v(" "),e("h2",{attrs:{id:"说一下对-react-和-vue-的理解-它们的异同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下对-react-和-vue-的理解-它们的异同"}},[v._v("#")]),v._v(" 说一下对 React 和 Vue 的理解，它们的异同")]),v._v(" "),e("p",[v._v("公司：网易、脉脉、快手")]),v._v(" "),e("p",[v._v("分类：React、Vue")]),v._v(" "),e("p",[v._v("答案&解析")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("对比点")]),v._v(" "),e("th",[v._v("Vue")]),v._v(" "),e("th",[v._v("React")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[e("strong",[v._v("定位")])]),v._v(" "),e("td",[v._v("框架（集成度更高）")]),v._v(" "),e("td",[v._v("库（专注于视图层）")])]),v._v(" "),e("tr",[e("td",[e("strong",[v._v("语法风格")])]),v._v(" "),e("td",[v._v("模板语法（"),e("code",[v._v("template")]),v._v("）+ Options API / Composition API")]),v._v(" "),e("td",[v._v("JSX 语法（JS 写 HTML）")])]),v._v(" "),e("tr",[e("td",[e("strong",[v._v("响应式原理")])]),v._v(" "),e("td",[v._v("Vue2："),e("code",[v._v("Object.defineProperty")]),e("br"),v._v("Vue3："),e("code",[v._v("Proxy")])]),v._v(" "),e("td",[v._v("通过 "),e("code",[v._v("useState")]),v._v(" 等 Hook 来管理状态，依赖 immutable 设计")])]),v._v(" "),e("tr",[e("td",[e("strong",[v._v("状态管理")])]),v._v(" "),e("td",[v._v("官方主推 Vuex（现转向 Pinia）")]),v._v(" "),e("td",[v._v("Redux、MobX、Zustand、Recoil 等可选方案")])]),v._v(" "),e("tr",[e("td",[e("strong",[v._v("路由支持")])]),v._v(" "),e("td",[v._v("官方提供 Vue Router")]),v._v(" "),e("td",[v._v("需要引入第三方 React Router")])]),v._v(" "),e("tr",[e("td",[e("strong",[v._v("模板和逻辑分离")])]),v._v(" "),e("td",[v._v("模板和逻辑在单文件组件中清晰分离")]),v._v(" "),e("td",[v._v("使用 JSX，将逻辑和视图融合在一起")])]),v._v(" "),e("tr",[e("td",[e("strong",[v._v("组件通信")])]),v._v(" "),e("td",[v._v("props、emit、provide/inject")]),v._v(" "),e("td",[v._v("props、context、状态提升")])]),v._v(" "),e("tr",[e("td",[e("strong",[v._v("指令系统")])]),v._v(" "),e("td",[v._v("拥有丰富的指令（如 "),e("code",[v._v("v-if")]),v._v(", "),e("code",[v._v("v-for")]),v._v(", "),e("code",[v._v("v-model")]),v._v("）")]),v._v(" "),e("td",[v._v("没有类似指令，使用 JS 逻辑控制")])]),v._v(" "),e("tr",[e("td",[e("strong",[v._v("类型支持")])]),v._v(" "),e("td",[v._v("Vue3 对 TypeScript 支持增强，但仍不如 React 顺手")]),v._v(" "),e("td",[v._v("天生适合 TypeScript，类型推导较好")])])])]),v._v(" "),e("p",[v._v("响应式区别")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("特性")]),v._v(" "),e("th",[e("strong",[v._v("Vue（2.x & 3.x）")])]),v._v(" "),e("th",[e("strong",[v._v("React（16+）")])])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("响应式核心")]),v._v(" "),e("td",[v._v("Vue2："),e("code",[v._v("Object.defineProperty")]),e("br"),v._v("Vue3："),e("code",[v._v("Proxy")])]),v._v(" "),e("td",[v._v("状态不可变 + 重新渲染组件（"),e("code",[v._v("useState")]),v._v(", "),e("code",[v._v("useReducer")]),v._v("）")])]),v._v(" "),e("tr",[e("td",[v._v("数据是“可变”的？")]),v._v(" "),e("td",[v._v("✅ 响应式对象是可变的（自动追踪依赖）")]),v._v(" "),e("td",[v._v("❌ React 状态不可变（需要用 setState 触发更新）")])]),v._v(" "),e("tr",[e("td",[v._v("自动依赖追踪")]),v._v(" "),e("td",[v._v("✅ 是的，模板中使用的数据 Vue 会自动追踪依赖")]),v._v(" "),e("td",[v._v("❌ React 不追踪依赖，靠函数闭包和渲染过程")])]),v._v(" "),e("tr",[e("td",[v._v("响应式细粒度")]),v._v(" "),e("td",[v._v("✅ 精细（只更新受影响的数据）")]),v._v(" "),e("td",[v._v("⛔ 粗粒度（组件级重渲染）")])]),v._v(" "),e("tr",[e("td",[v._v("响应式触发更新")]),v._v(" "),e("td",[v._v("数据变化 → 自动更新部分视图")]),v._v(" "),e("td",[e("code",[v._v("setState/useState")]),v._v(" → 整个组件重新执行 render")])]),v._v(" "),e("tr",[e("td",[v._v("深层数据变更支持")]),v._v(" "),e("td",[v._v("Vue2 对数组、对象有些限制；Vue3 基于 Proxy 改进很多")]),v._v(" "),e("td",[v._v("对象/数组变化不会自动追踪，需要手动处理或重新设置状态")])]),v._v(" "),e("tr",[e("td",[v._v("开发者感知度")]),v._v(" "),e("td",[v._v("低感知（写代码时少考虑响应细节）")]),v._v(" "),e("td",[v._v("高感知（需要关注闭包、依赖、状态引用变化）")])])])]),v._v(" "),e("h2",{attrs:{id:"说一下-vue3-与-vue2-的对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下-vue3-与-vue2-的对比"}},[v._v("#")]),v._v(" 说一下 Vue3 与 Vue2 的对比")]),v._v(" "),e("p",[v._v("公司：高德")]),v._v(" "),e("p",[v._v("分类：Vue")]),v._v(" "),e("p",[v._v("答案&解析")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("项目")]),v._v(" "),e("th",[v._v("Vue 2")]),v._v(" "),e("th",[v._v("Vue 3")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("核心机制")]),v._v(" "),e("td",[e("code",[v._v("Object.defineProperty")]),v._v(" 劫持")]),v._v(" "),e("td",[e("code",[v._v("Proxy")]),v._v(" 代理")])]),v._v(" "),e("tr",[e("td",[v._v("支持深层结构")]),v._v(" "),e("td",[v._v("不完全（数组、嵌套对象需手动处理）")]),v._v(" "),e("td",[v._v("完全支持，性能更好")])]),v._v(" "),e("tr",[e("td",[v._v("性能")]),v._v(" "),e("td",[v._v("对大对象、嵌套结构较弱")]),v._v(" "),e("td",[v._v("性能显著提升，更自然的响应式处理")])]),v._v(" "),e("tr",[e("td",[v._v("响应式 API")]),v._v(" "),e("td",[e("code",[v._v("data")]),v._v(", "),e("code",[v._v("computed")]),v._v(", "),e("code",[v._v("watch")])]),v._v(" "),e("td",[v._v("全新的 "),e("code",[v._v("reactive")]),v._v(", "),e("code",[v._v("ref")]),v._v(", "),e("code",[v._v("computed")]),v._v(", "),e("code",[v._v("watch")]),v._v(" 等组合式 API")])])])]),v._v(" "),e("h2",{attrs:{id:"vue-对数组的方法做了重写的操作-如何实现对-vue2-中对数组操作的-push-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-对数组的方法做了重写的操作-如何实现对-vue2-中对数组操作的-push-方法"}},[v._v("#")]),v._v(" vue 对数组的方法做了重写的操作，如何实现对 vue2 中对数组操作的 push()方法")]),v._v(" "),e("p",[v._v("公司：高德")]),v._v(" "),e("p",[v._v("分类：Vue")]),v._v(" "),e("p",[v._v("答案&解析")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("调用自定义的 push 方法；")])]),v._v(" "),e("li",[e("p",[v._v("执行原生 push 逻辑；")])]),v._v(" "),e("li",[e("p",[v._v("手动触发依赖（dep.notify()）来更新视图；")])]),v._v(" "),e("li",[e("p",[v._v("对新增元素做递归响应式处理（如果是对象）。")])])]),v._v(" "),e("h2",{attrs:{id:"简述-vue-的生命周期以及每个阶段做的事"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简述-vue-的生命周期以及每个阶段做的事"}},[v._v("#")]),v._v(" 简述 Vue 的生命周期以及每个阶段做的事")]),v._v(" "),e("p",[v._v("公司：脉脉、58")]),v._v(" "),e("p",[v._v("分类：Vue")]),v._v(" "),e("p",[v._v("答案&解析")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("钩子")]),v._v(" "),e("th",[v._v("常用操作示例")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("beforeCreate")]),v._v(" "),e("td",[v._v("初始化前的准备（很少用）")])]),v._v(" "),e("tr",[e("td",[v._v("created")]),v._v(" "),e("td",[v._v("请求接口、初始化数据、事件监听")])]),v._v(" "),e("tr",[e("td",[v._v("beforeMount")]),v._v(" "),e("td",[v._v("访问 DOM 前的准备")])]),v._v(" "),e("tr",[e("td",[v._v("mounted")]),v._v(" "),e("td",[v._v("DOM 相关操作（第三方库初始化）")])]),v._v(" "),e("tr",[e("td",[v._v("beforeUpdate")]),v._v(" "),e("td",[v._v("更新前对比旧状态、清理操作")])]),v._v(" "),e("tr",[e("td",[v._v("updated")]),v._v(" "),e("td",[v._v("更新后执行依赖 DOM 变更的逻辑")])]),v._v(" "),e("tr",[e("td",[v._v("beforeDestroy")]),v._v(" "),e("td",[v._v("清除定时器、解绑事件、销毁资源")])]),v._v(" "),e("tr",[e("td",[v._v("destroyed")]),v._v(" "),e("td",[v._v("完全销毁后的收尾工作")])])])]),v._v(" "),e("h2",{attrs:{id:"说一下-vue-组件的通信方式都有哪些-父子组件-兄弟组件-多级嵌套组件等等"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下-vue-组件的通信方式都有哪些-父子组件-兄弟组件-多级嵌套组件等等"}},[v._v("#")]),v._v(" 说一下 Vue 组件的通信方式都有哪些？(父子组件，兄弟组件，多级嵌套组件等等)")]),v._v(" "),e("p",[v._v("公司：脉脉、58")]),v._v(" "),e("p",[v._v("分类：Vue")]),v._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/lgwebdream/FE-Interview/issues/288",target:"_blank",rel:"noopener noreferrer"}},[v._v("答案&解析"),e("OutboundLink")],1)]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("通信场景")]),v._v(" "),e("th",[v._v("方式")]),v._v(" "),e("th",[v._v("适用情况")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("父传子")]),v._v(" "),e("td",[v._v("Props")]),v._v(" "),e("td",[v._v("简单单向数据传递")])]),v._v(" "),e("tr",[e("td",[v._v("子传父")]),v._v(" "),e("td",[e("code",[v._v("$emit")])]),v._v(" "),e("td",[v._v("子组件通知父组件")])]),v._v(" "),e("tr",[e("td",[v._v("兄弟组件")]),v._v(" "),e("td",[v._v("父组件中转、事件总线、Vuex")]),v._v(" "),e("td",[v._v("兄弟间通信，状态共享")])]),v._v(" "),e("tr",[e("td",[v._v("多级嵌套组件")]),v._v(" "),e("td",[v._v("Provide/Inject、Vuex")]),v._v(" "),e("td",[v._v("祖孙传值、复杂状态共享")])]),v._v(" "),e("tr",[e("td",[v._v("全局状态管理")]),v._v(" "),e("td",[v._v("Vuex")]),v._v(" "),e("td",[v._v("大型项目复杂状态管理")])])])]),v._v(" "),e("h2",{attrs:{id:"说一下-vuex-的原理以及自己的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下-vuex-的原理以及自己的理解"}},[v._v("#")]),v._v(" 说一下 Vuex 的原理以及自己的理解")]),v._v(" "),e("p",[v._v("公司：脉脉")]),v._v(" "),e("p",[v._v("分类：Vue")]),v._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/lgwebdream/FE-Interview/issues/287",target:"_blank",rel:"noopener noreferrer"}},[v._v("答案&解析"),e("OutboundLink")],1)]),v._v(" "),e("p",[v._v("Vuex 设计思想理解")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("单一数据源 "),e("br"),v._v("\n让整个应用的状态集中在一个地方，避免多处状态不一致和难以维护的问题。")])]),v._v(" "),e("li",[e("p",[v._v("明确的状态变更路径 "),e("br"),v._v("\n只有 mutation 可以更改状态，且必须同步执行，这让状态变更可追踪、易于调试（配合 devtools）。\n通过 action 执行异步操作，把异步和同步的职责分离。")])]),v._v(" "),e("li",[e("p",[v._v("利用 Vue 响应式系统 "),e("br"),v._v("\n状态是响应式的，组件与状态的绑定是自动的，无需手动更新视图。")])]),v._v(" "),e("li",[e("p",[v._v("模块化支持 "),e("br"),v._v("\n大型项目时，state/mutation/action/getter 都可拆分成模块，方便分工协作和维护。")])])]),v._v(" "),e("h2",{attrs:{id:"说一下-vue-的-nexttick-原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下-vue-的-nexttick-原理"}},[v._v("#")]),v._v(" 说一下 Vue 的 $nextTick 原理")]),v._v(" "),e("p",[v._v("公司：自如")]),v._v(" "),e("p",[v._v("分类：Vue")]),v._v(" "),e("p",[v._v("答案&解析")]),v._v(" "),e("ul",[e("li",[v._v("Vue 会把需要更新的 DOM 操作推入一个异步队列（异步批处理）。")]),v._v(" "),e("li",[v._v("$nextTick 实质是基于异步任务机制（microtask 或 macrotask）注册一个回调，在 DOM 更新循环结束后执行。")]),v._v(" "),e("li",[v._v("Vue 优先使用 Promise.then（microtask），其次用 MutationObserver，再其次 setImmediate，最后 setTimeout。")])]),v._v(" "),e("h2",{attrs:{id:"vue-子组件和父组件执行顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-子组件和父组件执行顺序"}},[v._v("#")]),v._v(" Vue 子组件和父组件执行顺序")]),v._v(" "),e("p",[v._v("分类：Vue")]),v._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/lgwebdream/FE-Interview/issues/653",target:"_blank",rel:"noopener noreferrer"}},[v._v("答案&解析"),e("OutboundLink")],1)]),v._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("父 beforeCreate → 父 created → 父 beforeMount\n      ↓\n    子 beforeCreate → 子 created → 子 beforeMount → 子 mounted\n      ↓\n父 mounted\n")])])]),e("h2",{attrs:{id:"vuex-和-localstorage-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex-和-localstorage-的区别"}},[v._v("#")]),v._v(" Vuex 和 localStorage 的区别")]),v._v(" "),e("p",[v._v("公司：高思教育")]),v._v(" "),e("p",[v._v("分类：Vue")]),v._v(" "),e("p",[v._v("答案&解析")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("名称")]),v._v(" "),e("th",[v._v("作用")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[e("strong",[v._v("Vuex")])]),v._v(" "),e("td",[v._v("Vue.js 官方状态管理库，管理应用中的"),e("strong",[v._v("全局状态")]),v._v("，用于组件间共享和同步状态。")])]),v._v(" "),e("tr",[e("td",[e("strong",[v._v("localStorage")])]),v._v(" "),e("td",[v._v("浏览器本地存储，用于持久化存储数据，即使刷新或关闭浏览器数据依然存在。")])])])]),v._v(" "),e("h2",{attrs:{id:"vue-双向绑定原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-双向绑定原理"}},[v._v("#")]),v._v(" Vue 双向绑定原理")]),v._v(" "),e("p",[v._v("公司：高思教育、安居客")]),v._v(" "),e("p",[v._v("分类：Vue")]),v._v(" "),e("p",[v._v("答案&解析")]),v._v(" "),e("p",[v._v("Vue 双向绑定原理核心是 数据劫持 + 发布-订阅模式，")]),v._v(" "),e("p",[v._v("数据劫持（Object.defineProperty）：通过 Object.defineProperty | proxy 拦截对象属性的访问和赋值操作，实现数据的响应式。")]),v._v(" "),e("p",[v._v("发布-订阅模式：每个数据被劫持后，建立一个依赖收集器（Dep），当数据变化时通知所有订阅该数据的 watcher 进行更新。")]),v._v(" "),e("p",[v._v("Watcher：监听器，负责在数据变化时更新视图。")]),v._v(" "),e("p",[v._v("模板编译：Vue 编译模板时，会将模板中的变量解析成对应的响应式数据绑定。")]),v._v(" "),e("h2",{attrs:{id:"说一下-vue-的-keep-alive-是如何实现的-具体缓存的是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下-vue-的-keep-alive-是如何实现的-具体缓存的是什么"}},[v._v("#")]),v._v(" 说一下 Vue 的 keep-alive 是如何实现的，具体缓存的是什么？")]),v._v(" "),e("p",[v._v("公司：快手")]),v._v(" "),e("p",[v._v("分类：Vue")]),v._v(" "),e("p",[v._v("答案&解析")]),v._v(" "),e("p",[v._v("<keep-alive> 是 Vue 内置的一个抽象组件，专门用来缓存包裹的动态组件实例，避免重复创建和销毁，从而提升性能，尤其常用在路由视图（<router-view>）或动态组件切换中。")]),v._v(" "),e("p",[v._v("它的核心目的就是 缓存组件实例及其 DOM，切换时不销毁，保持状态和 DOM 结构。")]),v._v(" "),e("p",[v._v("实现原理")]),v._v(" "),e("p",[v._v("<keep-alive> 内部维护一个 缓存池 cache，用一个对象存储已缓存的组件实例，key 通常是组件的 VNode.key。")]),v._v(" "),e("p",[v._v("当包裹的动态组件切换时，keep-alive 会判断目标组件是否已缓存：")]),v._v(" "),e("p",[v._v("是：直接复用缓存实例，挂载对应 DOM；")]),v._v(" "),e("p",[v._v("否：创建新实例并缓存。")]),v._v(" "),e("h2",{attrs:{id:"vue3比vue2性能提升"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3比vue2性能提升"}},[v._v("#")]),v._v(" Vue3比Vue2性能提升")]),v._v(" "),e("p",[v._v("回顾Vue2，我们知道每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把用到的数据property记录为依赖，当依赖发生改变，触发setter，则会通知watcher，从而使关联的组件重新渲染。\n因此，Vue3在编译阶段，做了进一步优化：")]),v._v(" "),e("p",[v._v("① diff算法优化\nvue3在diff算法中相比vue2增加了静态标记，其作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较。")]),v._v(" "),e("p",[v._v("② 静态提升\nVue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。免去了重复的创建操作，优化内存。\n没做静态提升之前，未参与更新的元素也在render函数内部，会重复创建阶段。\n做了静态提升后，未参与更新的元素，被放置在render 函数外，每次渲染的时候只要取出即可。同时该元素会被打上静态标记值为-1，特殊标志是负整数表示永远不会用于 Diff。")]),v._v(" "),e("p",[v._v("③ 事件监听缓存\n默认情况下绑定事件行为会被视为动态绑定（没开启事件监听器缓存），所以每次都会去追踪它的变化。开启事件侦听器缓存后，没有了静态标记。也就是说下次diff算法的时候直接使用。")]),v._v(" "),e("p",[v._v("④ SSR优化\n当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染。")]),v._v(" "),e("h2",{attrs:{id:"vue3-0里为什么要用-proxy-api-替代-defineproperty-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0里为什么要用-proxy-api-替代-defineproperty-api"}},[v._v("#")]),v._v(" Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？")]),v._v(" "),e("p",[v._v("1、vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式。但是存在以下的问题：")]),v._v(" "),e("p",[v._v("检测不到对象属性的添加和删除\n数组API方法无法监听到\n需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题")]),v._v(" "),e("p",[v._v("2、proxy：监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作。\n总结：")]),v._v(" "),e("p",[v._v("Object.defineProperty只能遍历对象属性进行劫持\nProxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的\nProxy可以直接监听数组的变化（push、shift、splice）\nProxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等，这是Object.defineProperty不具备的")]),v._v(" "),e("h2",{attrs:{id:"vue3-0响应式原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0响应式原理"}},[v._v("#")]),v._v(" Vue3.0响应式原理")]),v._v(" "),e("p",[v._v("1、性能提升")]),v._v(" "),e("p",[v._v("响应式性能提升，由原来的 Object.defineProperty 改为基于ES6的 Proxy ，使其速度更快\n重写了 Vdom (diff算法优化，增加静态标志)\n进行模板编译优化（静态提升，不参与更新的元素只被创建一次）\n更加高效的组件初始化")]),v._v(" "),e("p",[v._v("2、更好的支持 typeScript")]),v._v(" "),e("p",[v._v("Vue.js 2.x 选用 Flow 做类型检查，来避免一些因类型问题导致的错误，但是 Flow 对于一些复杂场景类型的检查，支持得并不好。\nVue.js 3.0 抛弃了 Flow ，使用 TypeScript 重构了整个项目\nTypeScript 提供了更好的类型检查，能支持复杂的类型推断")]),v._v(" "),e("p",[v._v("3、新增 Composition API\nComposition API 是 vue3 新增的功能，比 mixin 更强大。它可以把各个功能模块独立开来，提高代码逻辑的可复用性，同时代码压缩性更强。\n在 Vue3 中，定义 methods、watch、computed、data数据等都放在了 setup() 函数中。\nsetup()函数会在created()生命周期之前执行。执行顺序为：beforeCreate > setup > created")]),v._v(" "),e("p",[v._v("4、新增组件")]),v._v(" "),e("p",[v._v("Fragment 不再限制 template 只有一个根节点。\nTeleport 传送门，允许我们将控制的内容传送到任意的 DOM 中。\nSuspense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验。")]),v._v(" "),e("p",[v._v("5、Tree-shaking：支持摇树优化\n摇树优化后会将不需要的模块修剪掉，真正需要的模块打到包内。优化后的项目体积只有原来的一半，加载速度更快。")]),v._v(" "),e("p",[v._v("6、Custom Renderer API： 自定义渲染器\n实现 DOM 的方式进行 WebGL 编程。")]),v._v(" "),e("h2",{attrs:{id:"watch-和-watcheffect-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch-和-watcheffect-的区别"}},[v._v("#")]),v._v(" watch 和 watchEffect 的区别？")]),v._v(" "),e("p",[v._v("watch 和 watchEffect 都是监听器，watchEffect 是一个副作用函数。它们之间的区别有：")]),v._v(" "),e("p",[v._v("watch ：既要指明监视的数据源，也要指明监视的回调。")]),v._v(" "),e("p",[v._v("而 watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。")]),v._v(" "),e("p",[v._v("watch 运行的时候不会立即执行，值改变后才会执行，而 watchEffect 运行后可立即执行。这一点可以通过 watch 的配置项 immediate 改变。")]),v._v(" "),e("p",[v._v("watchEffect有点像 computed ：")]),v._v(" "),e("p",[v._v("但 computed 注重的计算出来的值（回调函数的返回值）， 所以必须要写返回值。\n而 watcheffect注重的是过程（回调函数的函数体），所以不用写返回值。")]),v._v(" "),e("p",[v._v("watch与 vue2.x中 watch 配置功能一致，但也有两个小坑")]),v._v(" "),e("p",[v._v("监视 reactive 定义的响应式数据时，oldValue 无法正确获取，强制开启了深度监视（deep配置失效）\n监视 reactive 定义的响应式数据中某个属性时，deep配置有效。")]),v._v(" "),e("h2",{attrs:{id:"v-if-和-v-for-的优先级哪个高"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-for-的优先级哪个高"}},[v._v("#")]),v._v(" v-if 和 v-for 的优先级哪个高？")]),v._v(" "),e("p",[v._v("在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。")])])}),[],!1,null,null,null);t.default=r.exports}}]);