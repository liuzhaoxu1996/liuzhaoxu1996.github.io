(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{365:function(t,_,v){"use strict";v.r(_);var a=v(25),s=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"_3-树、二叉树、二叉搜索树的实现和特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-树、二叉树、二叉搜索树的实现和特性"}},[t._v("#")]),t._v(" 3. 树、二叉树、二叉搜索树的实现和特性")]),t._v(" "),v("h2",{attrs:{id:"定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),v("p",[t._v("在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。")]),t._v(" "),v("h2",{attrs:{id:"结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结构"}},[t._v("#")]),t._v(" 结构")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://pic1.zhimg.com/v2-00eb0b393ef3b9d629d823807980f8e8_r.jpg",alt:""}})]),t._v(" "),v("h2",{attrs:{id:"与树相关的术语"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#与树相关的术语"}},[t._v("#")]),t._v(" 与树相关的术语")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("树的结点（node）：包含一个数据元素及若干指向子树的分支；")])]),t._v(" "),v("li",[v("p",[t._v("孩子结点（child node）：结点的子树的根称为该结点的孩子；")])]),t._v(" "),v("li",[v("p",[t._v("双亲结点：B 结点是A 结点的孩子，则A结点是B 结点的双亲；")])]),t._v(" "),v("li",[v("p",[t._v("兄弟结点：同一双亲的孩子结点；堂兄结点：同一层上结点；")])]),t._v(" "),v("li",[v("p",[t._v("祖先结点: 从根到该结点的所经分支上的所有结点")])]),t._v(" "),v("li",[v("p",[t._v("子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙")])]),t._v(" "),v("li",[v("p",[t._v("结点层：根结点的层定义为1；根的孩子为第二层结点，依此类推；")])]),t._v(" "),v("li",[v("p",[t._v("树的深度：树中最大的结点层")])]),t._v(" "),v("li",[v("p",[t._v("结点的度：结点子树的个数")])]),t._v(" "),v("li",[v("p",[t._v("树的度：树中最大的结点度。")])]),t._v(" "),v("li",[v("p",[t._v("叶子结点：也叫终端结点，是度为 0 的结点；")])]),t._v(" "),v("li",[v("p",[t._v("分枝结点：度不为0的结点；")])]),t._v(" "),v("li",[v("p",[t._v("有序树：子树有序的树，比如家族树；")])]),t._v(" "),v("li",[v("p",[t._v("无序树：不考虑子树的顺序；")])])]),t._v(" "),v("h2",{attrs:{id:"二叉树遍历"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二叉树遍历"}},[t._v("#")]),t._v(" 二叉树遍历")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("前序: 根-左-右")])]),t._v(" "),v("li",[v("p",[t._v("中序: 左-根-右")])]),t._v(" "),v("li",[v("p",[t._v("后序: 左-右-根")])])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("递归")]),t._v(" "),v("p",[t._v("数的操作一般使用递归, 而不是用循环")])]),t._v(" "),v("h2",{attrs:{id:"二叉搜索树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二叉搜索树"}},[t._v("#")]),t._v(" 二叉搜索树")]),t._v(" "),v("p",[t._v("二叉搜索树, 也称二叉排序树, 有序二叉树, 排序二叉树, 是指一颗空树或者具有下列性质的二叉树")]),t._v(" "),v("ol",[v("li",[t._v("左子树上所有节点的值均小于它的根节点的值")]),t._v(" "),v("li",[t._v("右子树上所有节点的值均大于它的根节点的值")]),t._v(" "),v("li",[t._v("以此类推: 左,右子树也分别为二叉查找树(这就是重复性!)")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("时间复杂度")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("普通二叉树的查询和插入都是O(n)的")])]),t._v(" "),v("li",[v("p",[t._v("二叉搜索树的查询, 插入或删除都是O(logN)的, 说明二叉搜索树较普通二叉树提速了")])])])]),t._v(" "),v("h2",{attrs:{id:"堆-heap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆-heap"}},[t._v("#")]),t._v(" 堆 Heap")]),t._v(" "),v("p",[t._v("Heap: 可以迅速找到一堆数中的最大或者最小值的数据结构")]),t._v(" "),v("p",[t._v("将根节点最大的堆叫做大顶堆或者大根堆, 根节点最小的堆叫做小顶堆或小根堆\n常见的堆有二叉堆 斐波那契堆等")]),t._v(" "),v("p",[t._v("假设是大顶堆, 则常见操作(API):")]),t._v(" "),v("p",[t._v("find-max: O(1)\ndelete-max: O(logN)\ninsert(create): O(logN) or O(1)")]),t._v(" "),v("h2",{attrs:{id:"二叉堆性质"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二叉堆性质"}},[t._v("#")]),t._v(" 二叉堆性质")]),t._v(" "),v("p",[t._v("通过完全二叉树来实现(注意: 不是二叉搜索树);")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("完全二叉树")]),t._v(" "),v("p",[t._v("定义：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1 ~ 2h 个节点。")])]),t._v(" "),v("p",[t._v("二叉堆(大顶)它满足下列性质:")]),t._v(" "),v("ul",[v("li",[t._v("[性质1] 是一颗完全树")]),t._v(" "),v("li",[t._v("[性质2] 数中任意节点的值总是 >= 其子节点的值")])]),t._v(" "),v("p",[t._v("将数组转化成二叉堆")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://p3.ssl.qhimg.com/t01b189f9ea5dbd0999.png",alt:""}})]),t._v(" "),v("ul",[v("li",[t._v("根节点(顶堆元素)是: a[0]")]),t._v(" "),v("li",[t._v("索引为i的左孩子的索引是 (2 * i + 1)")]),t._v(" "),v("li",[t._v("索引为i的父节点的索引是 floor((i - 1) / 2)")])]),t._v(" "),v("h2",{attrs:{id:"二叉堆的主要操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二叉堆的主要操作"}},[t._v("#")]),t._v(" 二叉堆的主要操作")]),t._v(" "),v("ul",[v("li",[t._v("insert: 插入节点")]),t._v(" "),v("li",[t._v("delete: 删除节点")]),t._v(" "),v("li",[t._v("max-hepify: 调整分支节点堆性质")]),t._v(" "),v("li",[t._v("rebuildHeap: 重新构建整个二叉堆")]),t._v(" "),v("li",[t._v("sort: 排序")])]),t._v(" "),v("h2",{attrs:{id:"插入操作步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#插入操作步骤"}},[t._v("#")]),t._v(" 插入操作步骤:")]),t._v(" "),v("ol",[v("li",[t._v("新元素一律先插入到堆的尾部")]),t._v(" "),v("li",[t._v("依次向上调整整个堆的结构(一直到根即可)")]),t._v(" "),v("li",[t._v("时间复杂度: O(log2N)")])]),t._v(" "),v("p",[t._v("举例:")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/2020031815164116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,size_16,color_FFFFFF,t_70,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xvdmU2Njc3Njc",alt:""}})]),t._v(" "),v("h2",{attrs:{id:"删除堆顶操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#删除堆顶操作"}},[t._v("#")]),t._v(" 删除堆顶操作")]),t._v(" "),v("ol",[v("li",[t._v("将堆尾元素替换到顶部(即对顶被替代删除掉)")]),t._v(" "),v("li",[t._v("依次从根部向下调整整个堆的结构(一直到堆尾即可)")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://www.xiuxiubiu.com/img/in-post/binary-heap/heap-del.png",alt:""}})]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("实现")]),t._v(" "),v("p",[t._v("二叉堆是堆(优先队列 priority_queue)的一种常见且简单的实现; 但是并不是最优的实现")])])])}),[],!1,null,null,null);_.default=s.exports}}]);