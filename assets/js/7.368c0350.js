(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{364:function(t,a,s){"use strict";s.r(a);var r=s(25),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_2-哈希表-映射-集合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-哈希表-映射-集合"}},[t._v("#")]),t._v(" 2. 哈希表 映射 集合")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p1.ssl.qhimg.com/t0136186e89b9b5bf67.webp",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接查询与访问的数据结构。")])]),t._v(" "),s("li",[s("p",[t._v("存放记录的数组叫哈希表。")])]),t._v(" "),s("li",[s("p",[t._v("通常通过映射函数(哈希函数)将关键字直接对应到表中某个位置, 从而加快查找速度")])]),t._v(" "),s("li",[s("p",[t._v("JavaScript中的对象实际上是使用哈希表本身实现的")])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p5.ssl.qhimg.com/t01c187e37d9091ab49.png",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"哈希函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哈希函数"}},[t._v("#")]),t._v(" 哈希函数")]),t._v(" "),s("ul",[s("li",[t._v("把要存储的值映射到某个位置(下标)")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p2.ssl.qhimg.com/t011f401437554449c2.png",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"工程实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#工程实践"}},[t._v("#")]),t._v(" 工程实践")]),t._v(" "),s("ul",[s("li",[t._v("电话号码簿")]),t._v(" "),s("li",[t._v("用户信息表")]),t._v(" "),s("li",[t._v("缓存(LRU Cache)")]),t._v(" "),s("li",[t._v("键值对存储(Redis)")])]),t._v(" "),s("h2",{attrs:{id:"哈希碰撞"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哈希碰撞"}},[t._v("#")]),t._v(" 哈希碰撞")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p4.ssl.qhimg.com/t011f5c4663e84be152.png",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"解决哈希碰撞"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决哈希碰撞"}},[t._v("#")]),t._v(" 解决哈希碰撞")]),t._v(" "),s("ul",[s("li",[t._v("拉链法")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p4.ssl.qhimg.com/t010ce5c52ec4900385.png",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#复杂度"}},[t._v("#")]),t._v(" 复杂度")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p3.ssl.qhimg.com/t01dfdd56e52f2711d0.png",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"拉链法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#拉链法"}},[t._v("#")]),t._v(" 拉链法")]),t._v(" "),s("p",[t._v("hash碰撞解决方式，拉链法\n与开放定址法相比，拉链法有如下几个优点：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；")])]),t._v(" "),s("li",[s("p",[t._v("由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；")])]),t._v(" "),s("li",[s("p",[t._v("开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；")])]),t._v(" "),s("li",[s("p",[t._v("在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。")])])]),t._v(" "),s("h2",{attrs:{id:"拉链法的缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#拉链法的缺点"}},[t._v("#")]),t._v(" 拉链法的缺点")]),t._v(" "),s("p",[t._v("拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。")]),t._v(" "),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.educative.io/blog/data-strucutres-hash-table-javascript",target:"_blank",rel:"noopener noreferrer"}},[t._v("Data Structures 101: implement hash tables in JavaScript"),s("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=v.exports}}]);